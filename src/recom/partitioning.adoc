[#sec:partitioning]
## Partitioning

[#sec:partitioning:time]
### Time partitioning

Instructions providing explicit control of the state of microarchitectural
features may be convenient, such as those related to flushing cache contents,
making dirty cache contents become clean, and locking cache contents (e.g.
including probe instructions or other mechanisms to check whether specific cache
lines are stored in cache or not).
Also, instructions to reset the contents of branch predictors, the cache
replacement state and any other cache-like feature (e.g. branch target buffers)
may be convenient, to enforce a known processor state whenever needed.

These features refer to specific hardware components whose existence depends on
the actual implementation of the processor (e.g., first level, second level,
third level cache).
Hence, from a RISC-V point of view it may be convenient defining global
instructions (e.g., to flush all caches) and a framework to define
implementation specific instructions for processors, potentially as a new ISA
extension.

Although the `cbo.flush` instruction can be used to flush cache content, it is
an instruction defined from a software perspective, hence able to target memory
ranges and addresses.
Therefore, the size of the blocks being flushed as well as their initial
addresses will have a significant impact on the ability to flush the whole
cache.
An additional command to flush or invalidate a complete cache, with visibility
of the hardware implementation (i.e. being able to consider specific cache
memories) would help implement the typical application addressed in this
white paper.

[#sec:partitioning:mem]
### Memory partitioning

The RISC-V ecosystem is quite comprehensive on the memory space partitioning
side, incorporating diverse mechanisms at both the core and system levels to
isolate and protect multiple memory regions.
Among these, the RISC-V IOMMU specification has been ratified and is now quite
mature.
However, several enhancements could further strengthen the standard:

* Defense mechanisms against IOTLB-based side-channel attacks, for example,
using the IOMMU's HPM to identify suspicious DMA access patterns.
* Rethinking some in-memory data structures for better memory utilization and
granularity.
For instance, segregating DC MSI translation data into a separate structure
would enable efficient sharing of the IOMMU between MSI-capable and
MSI-incapable devices without wasting MSI fields in the DC.
* The current IOMMU specification envisions a monolithic architecture, where the
internal translation logic includes memory walkers and the caches/IOTBs.
This design could generate contention among devices as IOATCs (IOMMU Address
Translation Caches) are shared between them.
As a solution, the option of a distributed IOMMU architecture could be included,
i.e. a dedicated IOATC per device (or group of devices) and a central
translation unit containing the memory walkers.

In terms of ongoing developments, the RISC-V IOPMP and SPMP specifications are
near ratification, while a task group works on the integration and extension of
the WorldGuard solution, to be named _RISC-V Worlds_.
Key recommendations for RISC-V Worlds include:

* RISC-V Worlds itself offers a lean, easy model for initiator-side
identification on privilege-level granularity.
However, the current specification lacks support for virtualized environments.
This aspect is especially important for bare-metal applications without
address-translation (so called 'real-time virtualization'), where the Hypervisor
plays an essential role in the safety/security-concept.
Although some reference is made in the original specification, it maps the same
ID to both VS/VU-levels which is insufficient, if distinction between OS- and
User-level tasks in virtualized environments are required.
The TG is aware of this issue, and currently plans to defer it to a fast track
extension.
* In the real-time/mixed-criticality domain, support for more than `XLEN` WIDs
(World IDs) is needed.
This need is driven by growing MCU-complexity, integrating more and more (at
least partially virtualizable) initiators and cross-combinations of different
criticality/integrity levels.

[#sec:partitioning:other]
### Partitioning resources other than memory

The following options should be considered when drawing up designs integrating
speculative mechanisms that modify the behavior of a unit based on the behavior
of previously scheduled tasks:

* avoid their integration;
* provide support for their activation/deactivation;
* provide control features to inhibit the impact of previously scheduled tasks;
* or their internal operation should be made analyzable and their impact
boundable.

To facilitate the implementation of processor affinity or allocation, `mhartid`
should be a physical ID (not virtual or dynamically allocated).

The interconnect should minimize interference channels (e.g. multi-path NoC
instead of shared bus), allow analysis of arbitration mechanisms, and possibly
enforce isolation or budgeting mechanisms.
Designs using private hart resources should avoid the usage of the shared
interconnect for the communication between the hart and the private resource,
e.g. hart and its scratchpad.

The implementation of explicit communications may be eased by hardware
mechanisms such as mailboxes with fast notification.

When using a MSI controller, like the one provided by the AIA IMSIC (see
"`__Functional Safety White Paper__`", chapter "`__Partitioning__`", section
"`RISC-V solutions`"/"`Partitioning other resources than memory`"), consider
the impact of interrupt communications in the shared interconnect.
It is worth mentioning that the AIA specification suggests MSIs to be sent over
the main system bus.
We highlight that such design decision may be subject to sources of interference
on the main bus, which may undermine the jitter and WCET guarantees of the
interrupt latency.
Designs might consider dedicated paths for interrupt communications, like using
dedicated level signals or dedicated buses for message interrupts.

Simultaneous multithreading may be considered in some cores to enhance the
system performance.
However, this may lead to abundant time interferences at a very fine grain,
which are hard to master - if possible at all. In safety-critical systems this
feature should be disabled.

Some cores may share some "complex units" (e.g. a vector unit, floating point
units for complex math functions).
Uncontrolled sharing must be avoided, generally by software means such as
avoiding the use of those units altogether, allowing only one core to use them,
or explicitly time-sharing them so that concurrent accesses cannot occur.

The management of cache coherency could be expanded in the CMO task group, in
order to mitigate either the added traffic on the interconnect (in
directory-based cache coherency) or the interference channel of a shared bus (in
case of snooping).
